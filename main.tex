\documentclass[xcolor=dvipsname,handout]{beamer}

%\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{multimedia}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{comment}
\usepackage{framed,color}

\fboxsep=1pt%padding thickness
\fboxrule=1pt%border thickness
\usepackage{fancybox}

\usepackage{lipsum}
\usepackage{tabularx}
\usepackage{colortbl}
\usepackage{url}


\hypersetup{
	linkcolor=DarkSkyBlue,
	citecolor= DarkSkyBlue,
	filecolor= DarkSkyBlue,
	urlcolor= DarkSkyBlue
}


% COLOR-DEFINITION
%%%%%%%%%%%%%%%%%%%%%%%%
\definecolor{LightButter}{rgb}{0.98,0.91,0.31}
\definecolor{LightOrange}{rgb}{0.98,0.68,0.24}
\definecolor{LightChocolate}{rgb}{0.91,0.72,0.43}
\definecolor{LightChameleon}{rgb}{0.54,0.88,0.20}
\definecolor{LightSkyBlue}{rgb}{0.45,0.62,0.81}
\definecolor{LightPlum}{rgb}{0.68,0.50,0.66}
\definecolor{LightScarletRed}{rgb}{0.93,0.16,0.16}
\definecolor{LightGray}{rgb}{0.80,0.80,0.80}
\definecolor{Butter}{rgb}{0.93,0.86,0.25}
\definecolor{Orange}{rgb}{0.96,0.47,0.00}
\definecolor{Chocolate}{rgb}{0.75,0.49,0.07}
\definecolor{Chameleon}{rgb}{0.45,0.82,0.09}
\definecolor{SkyBlue}{rgb}{0.20,0.39,0.64}
\definecolor{Plum}{rgb}{0.46,0.31,0.48}
\definecolor{ScarletRed}{rgb}{0.80,0.00,0.00}
\definecolor{DarkButter}{rgb}{0.77,0.62,0.00}
\definecolor{DarkOrange}{rgb}{0.80,0.36,0.00}
\definecolor{DarkChocolate}{rgb}{0.56,0.35,0.01}
\definecolor{DarkChameleon}{rgb}{0.30,0.60,0.02}
\definecolor{DarkSkyBlue}{rgb}{0.12,0.29,0.53}
\definecolor{DarkPlum}{rgb}{0.36,0.21,0.40}
\definecolor{DarkScarletRed}{rgb}{0.64,0.00,0.00}



% HPI-THEME
%%%%%%%%%%%%%%%%%%%%%%%%
\RequirePackage{scrlfile}
%\ReplaceFile{beamerthemehpiswa.sty}{theme/beamerthemehpiswa.sty}
%\ReplaceFile{beamercolorthemehpiswa.sty}{theme/beamercolorthemehpiswa.sty}
%\ReplaceFile{beamerfontthemehpiswa.sty}{theme/beamerfontthemehpiswa.sty}
%\ReplaceFile{beamerinnerthemehpiswa.sty}{theme/beamerinnerthemehpiswa.sty}
%\ReplaceFile{beamerouterthemehpiswa.sty}{theme/beamerouterthemehpiswa.sty}
%\ReplaceFile{hpi.png}{theme/hpi.png}
\usetheme{hpiswa}


% BEAMER-Anpassungen
%%%%%%%%%%%%%%%%%%%%%%%%
\setbeamercolor{block title}{bg=DarkOrange}
\setbeamercolor{block body}{bg=Orange!20}
%\setbeamercolor{block title alerted}{bg=red}
\setbeamercolor{block body alerted}{bg=red!20}
%\setbeamercolor{block title example}{bg=green}
\setbeamercolor{block body example}{bg=DarkChameleon!20}
%\usecolortheme[RGB={205,173,0}]{structure}
\usecolortheme[RGB={30,74,135}]{structure}

\usecolortheme{orchid}
%\usefonttheme{professionalfonts}
%\useoutertheme[subsection=false]{smoothbars}
%\useinnertheme{rectangles}
%\setbeamertemplate{blocks}[shadow=true]

\setbeamercovered{transparent}
\setbeamertemplate{navigation symbols}{}%remove navigation symbols

\newcommand{\up}[1]{\ensuremath{^{{\tiny#1}}}}


% Eigene Anpassungen
%%%%%%%%%%%%%%%%%%%%

\definecolor{javared}{rgb}{0.6,0,0} % for strings
\definecolor{javagreen}{rgb}{0.25,0.5,0.35} % comments
\definecolor{javapurple}{rgb}{0.5,0,0.35} % keywords
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} % javadoc

\lstset{
  language=Java,
  basicstyle=\scriptsize\ttfamily,
  keywordstyle=\color{javapurple}\bfseries,
  stringstyle=\color{javared},
  commentstyle=\color{javagreen},
  morecomment=[s][\color{javadocblue}]{/**}{*/},
  tabsize=4,
  showspaces=false,
  showstringspaces=false,
  breaklines=true
}

% Explainframes:
\usepackage{ifthen}
\newboolean{isexplainframe}
\setboolean{isexplainframe}{false}
\mode<handout>{
\newenvironment{explainframe}[1]{
\setboolean{isexplainframe}{true}
\addtocounter{framenumber}{-1}
\setbeamertemplate{background}[grid][step=5mm,color=LightGray]
\begin{frame}{Handout only: #1}%
}{%
\end{frame}%
\setboolean{isexplainframe}{false}
}}
\mode<beamer>{
\excludecomment{explainframe}
}

\setbeamertemplate{footline}{%
	\leavevmode%
	\hbox{%
		\begin{beamercolorbox}[wd=.45\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
			\usebeamerfont{author in head/foot}\insertinstitute
		\end{beamercolorbox}%
		\begin{beamercolorbox}[wd=.2\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
			\usebeamerfont{title in head/foot}\insertshorttitle
		\end{beamercolorbox}%
		\begin{beamercolorbox}[wd=.35\paperwidth,ht=2.25ex,dp=1ex,right]{date in head/foot}%
			\usebeamerfont{date in head/foot}\insertshortdate{}\hspace*{2em}
			\insertframenumber{}\ifthenelse{\boolean{isexplainframe}}{E}{} / \inserttotalframenumber\hspace*{2ex}
	\end{beamercolorbox}}%
	\vskip0pt%
}


% Gliederung vor jedem Punkt:
\AtBeginSection[]{
\ifthenelse{\equal{\value{section}}{1}}{}{
\begin{frame}{Overview}
	\tableofcontents[currentsection, hideothersubsections]
\end{frame}
}
}


% Quote-Environment:

\renewenvironment{quote}{%
\begin{exampleblock}{}%
\begin{center}%
\begin{large}%
``}{%
''\end{large}%
\end{center}%
\end{exampleblock}}


\newcommand{\idea}[1]{$\rightarrow$ #1}



% Dokument-Meta-Daten:
%%%%%%%%%%%%%%%%%%%%%%%
\title{Truffle}
\subtitle{Virtual Machines and Execution Environments, WS2014/15}
\author{Jan Graichen, Fabio Niephaus, Matthias Springer, Malte Swart}
\date{\today}
\institute[2012]{Hasso Plattner Institute, Software Architecture Group}



\begin{document}

\begin{frame}[plain]
	\maketitle
\end{frame}
\begin{frame}{Overview}
	\tableofcontents[hideallsubsections]
\end{frame}

\section{How to Implement a Programming Language?}

\begin{frame}{How to Implement a Programming Language?}
    \begin{enumerate}
        \item Prototype: build an abstract syntax tree (AST) interpreter
        \begin{itemize}
          \item Easy to implement
          \item But slow (tree traversal, virtual method calls)
        \end{itemize}
        \item Make it fast
        \begin{itemize}
          \item Build a VM
          \item Compile AST to byte code
          \item JIT compilation
        \end{itemize}
        $\rightarrow$ Hard to implement, reinvent the wheel (memory management etc.)
    \end{enumerate}

    \vfill
    \begin{alertblock}{Truffle -- ``How it should be'':}
        Build a parser, define an AST and add language specific optimizations to make it fast.
    \end{alertblock}
\end{frame}


\section{How It Works}

\begin{frame}{Infrastructure \up{[2]}}
	\begin{figure}
        \includegraphics[width=\textwidth]{infrastructure.pdf}
        \caption{Interaction Graal/Truffle}
        \label{fig:interaction}
    \end{figure}
\end{frame}

\begin{explainframe}{Infrastructure}
	\begin{itemize}
    	\item Main components
        \begin{itemize}
            \item Truffle: provides guest language implementation API, support for optimization through node rewriting
        	\item Graal VM: HotSpot VM with Java API (instructured by Truffle)
        \end{itemize}
    	\item Two levels of optimization: Truffle, modified Graal VM
    \end{itemize}
\end{explainframe}

\begin{frame}[fragile]{Truffle: How It Works}
	\begin{itemize}
    	\item Truffle: AST interpreter framework
        \item Framework to easily implement specialized nodes
        \item Based on AST node rewriting
    \end{itemize}

       \vfill
       \pause
        \begin{block}{Sample Code (running example)}
    	\begin{lstlisting}
  function showSumMilliseconds(a, b) {
  	return (a + b) + " ms";
  }
      \end{lstlisting}
	\end{block}
\end{frame}

\begin{frame}[fragile]{Code Example \#1}
\begin{lstlisting}
public Object add(...) {
  Object left = leftNode.executeGeneric(...);
  Object right = rightNode.executeGeneric(...);

  if (left instanceof Long && right instanceof Long) {
    try {
      return ExactMath.addExact((Long) left, (Long) right);
    } catch (ArithmeticException ex) { }
  }

  if (left instanceof Long)
      left = ((Long) left).doubleValue();
  if (right instanceof Long)
      right = ((Long) right).doubleValue();

  if (left instanceof Double && right instanceof Double)
    return (Double) left + (Double) right;

  if (left instanceof String || right instanceof String)
    return left.toString() + right.toString();

  throw new UnsupportedSpecializationException(...);
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Node Rewriting \up{[2]}}
	\begin{figure}
    	\includegraphics[width=\textwidth]{node_rewriting.pdf}
        \label{fig:node_rewriting}
    \end{figure}

    \begin{block}{Sample Code}
   	\begin{lstlisting}
  function showSumMilliseconds(a, b) {
    return (a + b) + " ms";
  }
  showSumMilliseconds(1, 2);
    \end{lstlisting}
    \end{block}
\end{frame}

\begin{explainframe}{Node Rewriting}
    \begin{itemize}
        \item Generic nodes can handle all types.
        \item Guards check if the type specialization is still accurate.
        \item Partial evaluation once a tree stablized (no rewrites for a while) and is \emph{hot}.
        \begin{itemize}
        	\item Inlines \texttt{execute()} methods generates native code.
            \item Adds a check and a deoptimization call where a rewrite could happen.
        	\item Requires Graal (accessing compiler with Java code).
        \end{itemize}
        \item Truffle without Graal: interpreter mode
    \end{itemize}
\end{explainframe}

\begin{frame}[fragile]{Deoptimization \up{[2]}}
    \begin{figure}
        \includegraphics[width=\textwidth]{deopt.pdf}
        \caption{Deoptimization of Native Code}
        \label{fig:deopt}
    \end{figure}
    \begin{block}{Sample Code}
    	\begin{lstlisting}
  function showSumMilliseconds(a, b) {
    return (a + b) + " ms";
  }
  showSumMilliseconds(1, 2.5);
      \end{lstlisting}
	\end{block}
\end{frame}

\begin{explainframe}{Deoptimization}
    \begin{itemize}
        \item Switch from compiled mode to interpreted mode if safety guard fails
        \item Reconstruction of program state in interpreter
        \item Node rewriting (see previous slides)
        \begin{itemize}
            \item Switch from specialized node to generic node
            \item In this example: switch from \lstinline{integer} node to \lstinline{double} node directly, because \lstinline{double} nodes can also handle the \lstinline{integer} case
        \end{itemize}
        \item Partial evaluation (see previous slides)
    \end{itemize}
\end{explainframe}

\begin{frame}[fragile]{Code Example \#2 (using Annotation-Based DSL)}
  \begin{lstlisting}
public abstract class SLAddNode extends SLBinaryNode {
  @Specialization(rewriteOn=ArithmeticException.class)
  protected final long add(long left, long right) {
    return ExactMath.addExact(left, right);
  }

  @Specialization
  protected final double add(double left, double right) {
    return left + right;
  }

  @Specialization(guards = "isString")
  protected final String add(Object left, Object right) {
    return left.toString() + right.toString();
  }

  protected final boolean isString(Object a, Object b) {
    return a instanceof String || b instanceof String;
  }
}
  \end{lstlisting}
\end{frame}

\begin{frame}{Classes Generated by DSL Preprocessor}

	    \begin{figure}
        \centering
        \includegraphics[width=\textwidth]{nodes_less.pdf}
        \label{fig:gencodes}
    \end{figure}

\end{frame}

\begin{explainframe}{Code example}
	\begin{itemize}
    	\item Defined by language implementor: \\ \lstinline{SLExpressionNode}, \lstinline{SLBinaryNode}, \lstinline{SLAddNode}
        \item Generic case is generated by preprocessor
        \item \textbf{Uninitialized node:} replaces itself with specialized node
        \item \textbf{Monomorphic node:} one specialization only
        \item \textbf{Megamorphic node:} node can handle all types \\ (last item on linked list)
    \end{itemize}
\end{explainframe}

\section{Optimizations}
%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Type Decision Chains}
% Self

\begin{frame}{Type Decision Chains \up{[3]}}
  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{poly.pdf}
    \caption{Type Decision Chains as Truffle's implementation of Polymorphic Inline Caches}
    \label{fig:poly}
  \end{figure}
\end{frame}

\begin{frame}{Classes Generated by DSL Preprocessor}
  \begin{figure}
    \centering
    \includegraphics[width=\textwidth]{nodes.pdf}
  \end{figure}
\end{frame}

\begin{explainframe}{Type Decision Chains}
    \begin{itemize}
        \item \textbf{Polymorphic node:} node can handle a limited set of types (linked list via \lstinline{next} field): polymorphic inline caching
        \item Last element in linked list is megamorphic
    \end{itemize}
\end{explainframe}

\subsection{AST Inlining}

\begin{frame}[fragile]{AST Inlining \up{[3]}}
  \begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{image02-2.pdf}
    \label{fig:inlining}
  \end{figure}
\end{frame}

\begin{frame}[fragile]{Slightly More Complex Example}
    \begin{block}{Sample Code}
    \begin{lstlisting}
function foo() {
    return add(1, 2) + add("hello", "world");
}

function add(a, b) {
    return a + b;
}
    \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}[fragile]{AST Inlining \up{[3]}}
  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{image01-2.pdf}
    \caption{AST Evolution}
    \label{fig:inlining2}
  \end{figure}
\end{frame}

\begin{explainframe}{AST Inlining}
    \begin{itemize}
        \item Duplicate parts of the AST.
        \item Every duplicate subtree can have its own specialization.
    \end{itemize}
\end{explainframe}

\subsection{Assumptions}
\begin{frame}{Assumptions}
    \begin{alertblock}{Requirement}
        Global assumptions about system state, like:
        \begin{itemize}
          \item Redefinition of system objects or methods (JavaScript, Ruby)
          \item Current class hierarchy (Java)
        \end{itemize}
    \end{alertblock}
    \pause
    \vfill
    \begin{itemize}
        \item Global one-time switch; bool can be changed to \lstinline{false} once
        \pause
        \item Partial evaluation with constant value instead of check
        \pause
        \item On state change code is deoptimized
    \end{itemize}
    \pause
    \begin{center}
        \alert{No runtime overhead in compiled code}
    \end{center}
\end{frame}
\begin{frame}[fragile]{Code Example \#3: Assumption for Method Redefinition}
  \begin{lstlisting}
final class MyCallNode {
  private final MyFunction function;
  private final Assumption functionStable;

  protected SLDirectDispatchNode(...MyFunction function) {
    this.function = function;
    this.functionStable = function.getStableAssumption();
  }

  protected Object execute(...) {
    try {
      functionStable.check();
      return function.call(...);
    } catch(InvalidAssumptionException ex) {
      replace(...);
    }
  }
}
  \end{lstlisting}
\end{frame}

\subsection{Local Variables}
\begin{frame}{Local Variables}
    \begin{alertblock}{Requirement}
        Highly efficient access to local variables while simple modeling
        \begin{itemize}
          \item Modeled as an array on \texttt{Frame} object
          \item Access nodes must be specializable for dynamic profiling
        \end{itemize}
    \end{alertblock}
    \pause
    \vfill
    \begin{itemize}
        \item Escape analysis of local variable array access
        \pause
        \item Implicit single static assignment (SSA) form
        \pause
        \item Host compiler can optimize without flow analysis
        \pause
        \item \texttt{Frame} array never allocated except on deoptimization
    \end{itemize}
    \pause
    \begin{center}
        \alert{As fast as host language variables; optional  \texttt{Frame} facilities}
    \end{center}
\end{frame}

\begin{frame}[fragile]{Single Static Assignment (SSA) Form}
  \begin{block}{Original Sample Code}
  \begin{lstlisting}
if (condition) {
  x = value1 + value2;
} else {
  x = value2;
}
return x * 2;
  \end{lstlisting}
  \end{block}
  \pause
  \begin{block}{Sample Code in SSA Form}
  \begin{lstlisting}
if (condition) {
  x1 = value1 + value2;
} else {
  x2 = value2;
}
x3 = phi(x1, x2);
x4 = x3 * 2;
return x4;
  \end{lstlisting}
  \end{block}
\end{frame}

\begin{explainframe}{Single Static Assignment (SSA) Form}
  \begin{itemize}
    \item Every variable is only written once.
    \item \texttt{phi} nodes capture variables from different branches.
    \item Replaces read access with address from last write.
    \item All variables are implicitly final/constant.
    \item Makes it easier to do certain optimizations (e.g. dead code elimination, common subexpression elimination, \ldots).
  \end{itemize}
\end{explainframe}

\section{Applications}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Languages}
  \begin{block}{JavaScript}
    \begin{itemize}
      \item Specialization of JavaScript generic types
      \item Object prototype chain changing by "shape" (assumptions)
    \end{itemize}
  \end{block}
  \begin{block}{Ruby}
    \begin{itemize}
      \item Mostly method invocation $\rightarrow$ in-lining and shaping
      \item Method redefinitions via assumptions
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Debugging (1/3)}
  \begin{alertblock}{Problem}
  Normal debugging:
    \begin{itemize}
      \item Different behavior when debugging: Disabled or different optimizations, different runtime behavior
      \item (Extremely) slower execution -- may not practical to run production applications
    \end{itemize}
  \end{alertblock}

  \idea{Use node rewriting and assumption for nearly zero overhead debugging}
\end{frame}


\begin{frame}[fragile]{Debugging (2/3) \up{[1]}}
  \begin{columns}[T]
    \column{.4\textwidth}
      \begin{block}{Idea}
        Handle break points as simple AST nodes \\ Optimize using assumptions
      \end{block}

      \begin{lstlisting}
while x < y
  x += 1
  y -= 1
end
      \end{lstlisting}

    \column{.55\textwidth}
      \begin{figure}
        \centering
        \includegraphics[width=0.7\textwidth]{breakpoints-crop.pdf}
        \label{fig:breakpoints}
      \end{figure}
  \end{columns}


% Idea: Wrapper nodes (e.g. as potendial break point)

% \begin{enumerate}
%  \item Inactive points: define assumptions that they are not activated; truffle optimizes code as the breakpoint would not exists
%  \item Active point: assumption is invalidated, nodes are deopimizated
%  \item On execution: condition is executed, execution may halt; multiple executions triggers again optimization
% \end{enumerate}

% \idea{Zero overhead for inactive or never executed break points}

% \vspace{.3cm}

% Additional: Inline condition \& co for fast debug execution
\end{frame}


\begin{frame}{Debugging (3/3): Results \up{[1]}}
  \begin{figure}
    \includegraphics[width=\textwidth]{performance-debugging.pdf}
    \caption{Relative debugging performance in different Ruby VM implementations}
    \label{fig:debuggin_performance}
  \end{figure}
\end{frame}


\section{Summary}
%%%%%%%%%%%%%%%%%

\begin{frame}{Summary}
  \begin{itemize}
    \item Truffle is an AST interpreter framework
    %\item Truffle makes AST interpreters fast
    \item Truffle (like RPython) let developer concentrate on their domain, not implementing again a generic optimization technique
    \item Powerful Node Rewriting Technique supports easily implementing any kind of domain specialization
    \item Truffle supports so writing extremly fast makes AST interpreter
    %\item Truffle provides facilities to specialize AST nodes and makes interpreters even faster
  \end{itemize}
\end{frame}

\begin{frame}{Future Work}
    %Open, but could be one or more of the following topics:
    We want to dive deeper and look at interesting stuff in:
    \begin{itemize}
        \item Interaction with Graal VM
        \item Partial Evaluation
        \item Deoptimization
        \item DSL Preprocessor
        \item Type System
        \item JRuby
    \end{itemize}
\end{frame}

\section{References}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{References}
  \begin{description}
    \item[1]{C. Seaton, M. L. Van De Vanter, and M. Haupt. Debugging at full speed. In Proceedings of the 8th Workshop on Dynamic Languages and Applications (DYLA), 2014.}
    \item[2] T. Würthinger, C. Wimmer, A. Wöß, L. Stadler, G. Duboscq, C. Humer, G. Richards, D. Simon, M. Wolczko. One VM to Rule Them All, 2013.
    \item[3] T. Würthinger, A. Woß, L. Stadler, G. Duboscq, D. Simon, C. Wimmer. Self-Optimizing AST Interpreters, 2012.
  \end{description}
\end{frame}

\end{document}
